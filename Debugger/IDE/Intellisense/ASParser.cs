using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Debugger.IDE.Intellisense {   

    /// <summary>
    /// Doesn't parse Angelscript so much as it parses the C style header dumps
    /// generated by the script compiler
    /// </summary>
    public class ASParser {

        public void ParseDumpFile(StringReader rdr, Globals globals) {
            string line = "";
            while ((line = rdr.ReadLine()) != null) {
                if (line.Length == 0)
                    continue;
                if (line.Contains("class")) {
                    ParseDumpClass(line, rdr, globals);
                } else if (line.Contains("enum")) {
                    ParseDumpEnum(line, rdr, globals);
                } else if (line.StartsWith("// Global functions")) {
                    ParseDumpGlobFuncs(line, rdr, globals);
                } else if (line.StartsWith("// Global properties")) {
                    ParseDumpGlobProps(line, rdr, globals);
                } else if (line.StartsWith("// Global constants")) {
                    ParseDumpGlobProps(line, rdr, globals);
                }
            }
            _resolveNames(globals);
        }

        void _resolveNames(Globals globals) {
            foreach (string key in globals.GetPropertyNames()) {
                TypeInfo t = globals.GetProperty(key, true) as TypeInfo;
                if (t != null)
                {
                    if (!t.IsComplete)
                        globals.AddProperty(key, globals.GetTypeInfo(t.Name), -1, "");
                    if (t is TemplateInst)
                    {
                        TemplateInst ti = globals.GetProperty(key, true) as TemplateInst;
                        if (!ti.WrappedType.IsComplete)
                            ti.WrappedType = globals.GetTypeInfo(ti.WrappedType.Name);
                    }
                }
            }

            foreach (FunctionInfo f in globals.GetFunctions(null, true)) {
                f.ResolveIncompletion(globals);
            }

            foreach (TypeInfo type in globals.TypeInfo) {
                type.ResolveIncompletion(globals);
            }
        }

        void ParseDumpGlobFuncs(string line, StringReader rdr, Globals globals) {
            while ((line = rdr.ReadLine()) != null) {
                if (line.Length == 0)
                    return;
                if (line.StartsWith("/*") || line.StartsWith("//"))
                    continue;
                else {
                    globals.AddFunction(_parseFunction(line, globals));
                }
            }
        }

        void ParseDumpGlobProps(string line, StringReader rdr, Globals globals) {
            while ((line = rdr.ReadLine()) != null) {
                if (line.Length == 0)
                    return;
                if (line.StartsWith("/*") || line.StartsWith("//"))
                    continue;
                else {
                    string[] parts = line.Replace(";", "").Split(' '); //[TypeName] [PropertyName]
                    string pname = parts[0].EndsWith("@") ? parts[0].Substring(0, parts[0].Length - 1) : parts[0]; //handle
                    TypeInfo pType = null;
                    string myname = parts[1];
                    if (globals.ContainsTypeInfo(pname))
                        pType = globals.GetTypeInfo(pname);
                    if (pType == null) { //create temp type to resolve
                        pType = new TypeInfo() { Name = pname, IsComplete = false };
                    }
                    globals.AddProperty(myname, pType, -1, null);
                }
            }
        }

        void ParseDumpEnum(string line, StringReader rdr, Globals globals) {
            string[] nameparts = line.Split(' ');
            string enumName = nameparts[1];
            List<string> enumValues = new List<string>();
            while ((line = rdr.ReadLine()) != null) {
                if (line.Equals("};")) {
                    EnumInfo ret = new EnumInfo { Name = enumName };
                    ret.Values.AddRange(enumValues);
                    globals.AddTypeInfo(enumName, ret);
                    return;
                } else if (line.Contains(',')) {
                    int sub = line.IndexOf(',');
                    enumValues.Add(line.Substring(0, sub));
                }
            }
        }

        void ParseDumpClass(string line, StringReader rdr, Globals globals) {
            bool isTemplate = false;
            if (line.Contains("template <class T> "))
                isTemplate = true;
            string[] nameparts = line.Replace(",","").Replace("template <class T> ","").Split(' '); //dump the commas
            string classname = nameparts[1]; //class is first
            string classtype = nameparts[0]; //it might be an interface

            TypeInfo classInfo = new TypeInfo() { IsTemplate = isTemplate };
            classInfo.Name = classname;
            globals.AddTypeInfo(classInfo.Name, classInfo);

            for (int i = 3; i < nameparts.Length; ++i) { //list bases 2 would be :, 3 will be first basetype
                classInfo.BaseTypeStr.Add(nameparts[i]); //add a base class
            }

            bool inprops = false;
            bool nextReadOnly = false;
            bool nextProtected = false;
            while ((line = rdr.ReadLine()) != null) {
                if (line.Length == 0) //empty line
                    continue;
                if (line.StartsWith("{"))
                    continue;
                if (line.Equals("};")) {
                    //TODO: push our class
                    return;
                } else if (line.StartsWith("/* readonly */")) {
                    nextReadOnly = true;
                    continue;
                } else if (line.StartsWith("/* protected */")) {
                    nextProtected = true;
                    continue;
                } else if (line.StartsWith("/*")) {
                    continue;
                } else if (line.Contains("// Properties:")) {
                    inprops = true;
                } else if (line.StartsWith("//")) { // // Methods:
                    continue;
                } else if (inprops) { //property
                    string[] parts = line.Replace(";", "").Split(' '); //[TypeName] [PropertyName]
                    if (parts[0].Contains('<')) {
                        string templateType = parts[0].Substring(0, parts[0].IndexOf('<'));
                        string containedType = parts[0].Extract('<', '>');
                        TypeInfo wrapped = globals.GetTypeInfo(containedType);
                        TemplateInst ti = new TemplateInst() { Name = templateType, IsTemplate = true, WrappedType = wrapped != null ? wrapped : new TypeInfo { Name = containedType, IsComplete = false } };
                        classInfo.Properties[parts[1]] = ti;
                        classInfo.PropertyLines[parts[1]] = -1;
                        if (nextReadOnly)
                            classInfo.ReadonlyProperties.Add(parts[1]);
                        else if (nextProtected)
                            classInfo.ProtectedProperties.Add(parts[1]);
                    } else {
                        string pname = parts[0].EndsWith("@") ? parts[0].Substring(0, parts[0].Length - 1) : parts[0]; //handle
                        TypeInfo pType = null;
                        if (globals.ContainsTypeInfo(pname))
                            pType = globals.GetTypeInfo(pname);
                        if (pType == null) { //create temp type to resolve later
                            pType = new TypeInfo() { Name = pname, IsComplete = false };
                        }
                        classInfo.Properties[parts[1]] = pType;
                        classInfo.PropertyLines[parts[1]] = -1;
                        if (nextReadOnly)
                            classInfo.ReadonlyProperties.Add(parts[1]);
                        else if (nextProtected)
                            classInfo.ProtectedProperties.Add(parts[1]);
                    }
                    nextReadOnly = false;
                    nextProtected = false;

                } else { //function
                    classInfo.Functions.Add(_parseFunction(line, globals));
                    nextReadOnly = false;
                    nextProtected = false;
                }
            }
        }

        static FunctionInfo _parseFunction(string line, Globals globals) {
            int firstParen = line.IndexOf('(');
            int lastParen = line.LastIndexOf(')');
            string baseDecl = line.Substring(0, firstParen);
            string paramDecl = line.Substring(firstParen, lastParen - firstParen+1); //-1 for the ;
            string[] nameParts = baseDecl.Split(' ');
            TypeInfo retType = null;

            //TODO: split the name parts
            if (globals.ContainsTypeInfo(nameParts[0])) {
                retType = globals.GetTypeInfo(nameParts[0]);
            } else if (nameParts[0].Contains('<')) {
                string wrappedType = nameParts[0].Extract('<', '>');
                string templateType = nameParts[0].Replace(string.Format("<{0}>", wrappedType), "");
                TypeInfo wrapped = globals.GetTypeInfo(wrappedType);
                TemplateInst ti = new TemplateInst() { Name = nameParts[0], IsTemplate = true, WrappedType = wrapped != null ? wrapped : new TypeInfo { Name = wrappedType, IsComplete = false } };
                retType = ti;
            } else {
                retType = new TypeInfo() { Name = nameParts[0], IsPrimitive = false };
            }
            return new FunctionInfo {Name = nameParts[1], ReturnType = retType, Inner = paramDecl};
        }

    }
}
